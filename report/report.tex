%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{gensymb}
\usepackage{latexsym}
\usepackage{titlesec}
\usepackage{marvosym}
\usepackage{enumitem}
\usepackage[pdftex, hidelinks]{hyperref}
\usepackage{graphicx}
\usepackage{rotating}
\usepackage{caption}
\usepackage{makecell}
\usepackage{adjustbox}
\usepackage{placeins}
\usepackage{geometry}

\newcommand{\fncell}[3][]{\makecell[l]{#1 \\ #2 \\ #3}}
\newcommand{\PolOne}[2]{0.5$sin$({#1}) - 2$cos$({#1}) + $sin$({#2}) - 1.5$cos$({#2})}
\newcommand{\PolTwo}[2]{1.5$sin$({#1}) - $cos$({#1}) + 2$sin$({#2}) - 0.5$cos$({#2})}

\newcommand{\img}[3]{
  \begin{figure}
    \includegraphics[width=\linewidth]{img/{#1}.png}
    \centering
    \captionsetup{justification=centering}
    \caption{#2}
    \label{fig:#3}
  \end{figure}
}

\newcommand{\bench}[1]{
  \img{bench/#1}{Comparaison entre les différents algorithmes sur \MakeUppercase{#1}}{bench_#1}
}

\newcommand{\allBenchs}{
  \bench{sch}
  \bench{fons}
  \bench{zdt1}
  \bench{zdt2}
  \bench{zdt3}
  \bench{zdt4}
  \bench{zdt6}
}

\frenchbsetup{StandardItemLabels=true}

\author{Edorh François (EDOF19059507), Guison Vianney (GUIV30069402)}
\title{Rapport Projet de Métaheuristique en Optimisation\\
  \large{Sujet 1}}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage

\section{Introduction}
Nous avons choisi de comparer deux algorithmes génétiques, PESA et
IBEA, dans le cadre de l'optimisation multi-objectifs.\\

Le principe de chaque algorithme est rapidement évoqué, ainsi que des
exemples de solutions obtenues sur différents problèmes d'optimisation.\\

Pour finir, une comparaison des différents algorithmes est effectuée.

\newpage

\section{Problèmes de test}
Les problèmes d'optimisation utilisés pour comparer les deux
algorithmes sont les suivants.\\
Les solutions optimales des problèmes KUR et POL n'ayant pu être
déterminées, les métriques associées n'ont pu être calculées. Ainsi,
pour ces deux problèmes, une comparaison visuelle du front de Pareto a
été faite.\\

\begin{table}[ht]
  \centering
  \begin{adjustbox}{width=1\textwidth}
    \begin{tabular}{|c|c|c|c|c|c|}
      \hline
      Problème & $n$ & Domaine de définition & Fonctions objectifs & Solutions optimales & Commentaires\\
      \hline
      SCH & 1 & $[-10^3, 10^3]$ & \fncell[$f_1(x) = x^2$]{$f_2(x) = (x - 2)^2$} & $x \in{} [0, 2]$ & convexe\\
      \hline
      FON & 3 & $[-4, 4]$ & \fncell{$f_1(x) = 1 - \exp{(-\sum_{i = 1}^{3}{(x_i - \frac{1}{\sqrt{3}})^2})}$} & \makecell{$x_1 = x_2  = x_3$ \\ $\in{} [\frac{-1}{\sqrt{3}}, \frac{1}{\sqrt{3}}]$} & non convexe\\
      \hline
      POL & 2 & $[-\pi, \pi]$ & \makecell{
                                \fncell{
                                \fncell{$f_1(x) = 1  + (A_1 - B_1)^2 + (A_2 - B_2)^2$}{$f_2(x) = (x_1 + 3)^2 + (x_2 + 1)^2$}}{
                                \fncell{$A_1(x) = \PolOne{1}{2}$}{$A_2(x) = \PolTwo{1}{2}$}} \\
      \fncell{$B_1(x) = \PolOne{x_1}{x_2}$}{$B_2(x) = \PolTwo{x_1}{x_2}$}} &  & \makecell{non convexe, \\ discontinu}\\
      \hline
      KUR & 3 & $[-5, 5]$ & \fncell[$f_1(x) = \sum_{i = 1}^{n - 1} (-10\exp{(-0.2\sqrt{x_i^2 + x_{i + 1}^2})})$]
                                   {$f_2(x) = \sum_{i = 1}^{n - 1} (|x_1|^{0.8} + 5 $sin$(x_i^3))$}&  & non convexe\\
      \hline
      ZDT1 & 30 & $[0, 1]$ & \fncell[$f_1(x) = x_1$]
                             {$f_2(x) = g(x) [1 - \sqrt{x_1 / g(x)}]$}
                             {$g(x) = 1 + 9(\sum_{i = 2}^{n} x_i) / (n - 1)$}
                                                                   & \makecell{$x_1 \in{} [0, 1]$ \\ $x_i = 0$, \\ $i = 2, ..., n$} & convexe\\
      \hline
      ZDT2 & 30 & $[0, 1]$ & \fncell[$f_1(x) = x_1$]
                             {$f_2(x) = g(x) [1 - (x_1 / g(x))^2]$}
                             {$g(x) = 1 + 9(\sum_{i = 2}^{n} x_i) / (n - 1)$}
                                                                   & \makecell{$x_1 \in{} [0, 1]$ \\ $x_i = 0$, \\ $i = 2, ..., n$} & non convexe\\
      \hline
      ZDT3 & 30 & $[0, 1]$ & \fncell[$f_1(x) = x_1$]
                             {$f_2(x) = g(x) [1 - \sqrt{x_1 / g(x)} - \frac{x_1}{g(x)}$sin$(10\pi{}x_1)]$}
                             {$g(x) = 1 + 9(\sum_{i = 2}^{n} x_i) / (n - 1)$}
                                                                   & \makecell{$x_1 \in{} [0, 1]$ \\ $x_i = 0$, \\ $i = 2, ..., n$} & \makecell{convexe, \\ discontinu}\\
      \hline
      ZDT4 & 10 & \makecell{$x_1 \in{} [0, 1]$ \\ $x_i \in{} [-5, 5]$, \\ $i = 2, ..., n$}
               & \fncell[$f_1(x) = x_1$]
                 {$f_2(x) = g(x) [1 - \sqrt{x_1 / g(x)}]$}
                 {$g(x) = 1 + 10(n - 1) + (\sum_{i = 2}^{n} [x_i^2 - 10$cos$(4\pi{}x_i)])$}
                     & \makecell{$x_1 \in{} [0, 1]$ \\ $x_i = 0$, \\ $i = 2, ..., n$} & non convexe\\
      \hline
      ZDT6 & 10 & $[0, 1]$ & \fncell[$f_1(x) = 1 - \exp(-4x_1)$sin$^6(6\pi{}x_1)$]
                             {$f_2(x) = g(x) [1 - (f_1(x) / g(x))^2]$}
                             {$g(x) = 1 + 9[(\sum_{i = 2}^{n} x_i) / (n - 1)]^{0.25}$}
                                                                   & \makecell{$x_1 \in{} [0, 1]$ \\ $x_i = 0$, \\ $i = 2, ..., n$} & \makecell{non convexe, \\ non uniformément \\ réparti}\\
      \hline
    \end{tabular}
  \end{adjustbox}
  \caption{Problèmes utilisés} 
\end{table}

\section{PESA}

\subsection{Principe}

À l'instar de SPEA2, PESA utilise une archive. Celle-ci contient les
meilleurs individus rencontrés durant l'exécution de l'algorithme (un
paramètre de configuration définit sa taille). Les solutions
correspondent au contenu de cette archive à la dernière itération.\\

Pour remplir l'archive, on récupère les individus non dominés de la
population actuelle. Les individus non dominés par le contenu de
l'archive sont ensuite ajouté un à un à l'intérieur. Les éléments de
l'archive dominés par ce nouvel individu en sont retirés. De plus, si
l'archive est temporairement en surcharge suite à cet ajout, un
élément de l'archive parmis ceux ayant le \textit{squeeze factor}
(défini plus bas) le plus élevé est retiré.\\

Pour calculer le \textit{squeeze factor}, on divise l'espace objectif
en une hyper-grille de taille prédéfinie (paramètre de configuration
spécifiant le nombre de cases par dimension). On assigne ensuite
chaque individu à une case de cette hyper-grille en fonction de ses
valeurs objectives. Pour chaque individu, son \textit{squeeze factor}
correspond au nombre d'invidus contenus dans la
même case que lui.\\
De plus, ce \textit{squeeze factor} est aussi utilisé lors de la sélection:
plus il est élevé, moins l'individu est intéressant.\\

Lors de la création d'une nouvelle population (une fois que l'archive
a été mise à jour), il se passe la chose suivante:

\begin{itemize}
  
\item Un crossover se produit avec une probabilité $Pc$. On
  sélectionne deux individus de l'archive, par rapport à leur
  \textit{squeeze factor}, et on génère \textbf{un} enfant.\\
  
\item Si il n'y a pas de crossover, une mutation se produit
  (probabilité égale à $1 - Pc$). Dans ce cas, on sélectionne un
  individu de l'archive et on génère un nouvel individu par mutation
  de celui-ci (avec probabilité $Pm$).
  
\end{itemize}

Cela se répète jusqu'à ce que la nouvelle population contienne $N$
éléments.

\subsection{Résultats}
Les figures \ref{fig:pesa_sch_pareto} à \ref{fig:pesa_zdt6_pareto}
montrent des exemples d'exécution de l'algorithme sur différents
problèmes.\\

Il est à noter que les auteurs de PESA utilisent un codage binaire
avec une longueur de chromosome variant entre 80 et 900 allèles.

Du fait de notre implémentation du codage binaire (entier unique par
variable), nous sommes limité à 53 allèles.

De ce fait, nos résultats peuvent ne pas représenter les performances
réelles (i.e, avec une longueur suffisante) de cet algorithme.\\

Il est tout de même à noter que $\epsilon$, le plus petit nombre
positif tel que $(1 + \epsilon) \neq 1$ est égal à $2^{-52}$, soit le
plus petit nombre non nul que nous pouvons représenter avec 53
bits. On peut donc se poser la question quant à la pertinence d'un
encodage sur 900 allèles, étant donné que $\frac{\epsilon}{4}$ (soit $2^{-54}$)
n'influence déjà plus 0.5.\\
(En gardant en tête que pour 900 allèles, la plus petite valeur est
$2^{-899 } = 2.3661e^{-271}$)

\subsection{PESA2}

PESA2 a aussi été implémenté au vu du peu de différences entre les
deux algorithmes. La différence se situe au niveau de la sélection
(avant la comparaison par tournoi): dans PESA, on sélectionne un
individu en fonction de son \textit{squeeze factor}, alors que dans
PESA2 on sélectionne non pas un individu, mais une \textit{case}
(toujours en fonction du \textit{squeeze factor}), l'individu
sélectionné étant choisi au hasard parmis ceux présent dans
celle-ci.\\

Les auteurs avancent que cela permet de limiter le bias induit par le
\textit{squeeze factor}. En effet, si $n$ individus sont présents dans
une case (\textit{squeeze factor} $= n$), les chances de tomber sur un
de ces individus sont de $\frac{n}{N}$, avec $N$ le nombre total
d'invididus. Il y a donc plus de chances de sélectionner un individu
peu intéressant ($n$ grands) qu'un individu intéressant.

Au contraire, si l'on sélectionne les cases, la probabilité de
sélectionner un individu avec un \textit{squeeze factor} précis ne
dépend plus de la valeur de celui-ci et vaut $\frac{c}{C}$, avec $c$
le nombre de cases avec ce même \textit{squeeze factor} et $C$ le
nombre de cases occupées par au moins un individu.

\section{IBEA}

\subsection{Principe}

\subsection{Résultats}
Les figures \ref{fig:ibea_sch_pareto} à \ref{fig:ibea_zdt6_pareto}
montrent des exemples d'exécution de l'algorithme sur différents
problèmes.


\section{Comparaison}

Les algorithmes ayant de nombreuses différences de configuration, nous
avons décidé de les comparer en se basant sur leurs configurations
optimales: celles qui, d'après les auteurs ou après tests, donnent les
meilleurs résultats sur l'ensemble des problèmes traités.

Pour chaque configuration, le nombre de solutions visé est de
100. Ainsi, la population (ou l'archive) a été mise à cette taillle et
les paramètres qui en dépendent ont été définis en conséquence.\\

Les résultats de chacune des 1000 générations et ce sur 30 itérations
ont été enregistrés et comparés. Il est à noter que pour chaque
problème, la population initiale est la même à toutes les itérations
et pour tous les algorithmes.\\

De plus, les algorithmes NSGA2 et SPEA2, déjà implémentés durant le
TP2, sont aussi comparés.\\

Les figures \ref{fig:bench_sch} à \ref{fig:bench_zdt6} sont le
résultat de cette comparaison.

\FloatBarrier

\subsection{Configurations}

\begin{table}[ht]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \textbf{Propriété} & \textbf{Valeur}\\
    \hline
    $N$ & $100$  \\
    \hline
    $P_m$ & $\frac{1}{n}$  \\
    \hline
    Crossover & SBX$-20$ \\
    \hline
    Mutation & Polynomial$-20$ \\
    \hline
  \end{tabular}
  \caption{Configuration commune en codage réel} 
\end{table}

\begin{table}[ht]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \textbf{Propriété} & \textbf{Valeur}\\
    \hline
    $N$ & $100$  \\
    \hline
    $M$ & $100$  \\
    \hline
    $l$ & $53$  \\
    \hline
    $C$ & $32$  \\
    \hline
    $P_c$ & $0.7$  \\
    \hline
    $P_m$ & $\frac{1}{l}$  \\
    \hline
    Crossover & Uniform$-0.5$ \\
    \hline
    Mutation & Bit flip \\
    \hline
  \end{tabular}
  \caption{Configuration de PESA et PESA2 (codage binaire)} 
\end{table}

\begin{table}[ht]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \textbf{Propriété} & \textbf{Valeur}\\
    \hline
    $\kappa$ & $0.002$  \\
    \hline
    $P_c$ & $1$  \\
    \hline
    $P_m$ & $0.1$  \\
    \hline
  \end{tabular}
  \caption{Configuration de IBEA et IBEA+(0.002) (codage réel)} 
\end{table}
\FloatBarrier

La configuration d'IBEA+(0.05) est la même que celle
précédente, mais avec $\kappa = 0.05$.

\begin{table}[ht]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \textbf{Propriété} & \textbf{Valeur}\\
    \hline
    $\kappa$ & $0.05$  \\
    \hline
    $P_c$ & $1$  \\
    \hline
    $P_m$ & $0.1$  \\
    \hline
  \end{tabular}
  \caption{Configuration de IBEA+(0.05) (codage réel)} 
\end{table}

\begin{table}[ht]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \textbf{Propriété} & \textbf{Valeur}\\
    \hline
    $P_c$ & $0.8$  \\
    \hline
  \end{tabular}
  \caption{Configuration de NSGA2 (codage réel)} 
\end{table}

\begin{table}[ht]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \textbf{Propriété} & \textbf{Valeur}\\
    \hline
    $M$ & $100$  \\
    \hline
    $P_c$ & $0.8$  \\
    \hline
  \end{tabular}
  \caption{Configuration de SPEA2 (codage réel)} 
\end{table}

\FloatBarrier

\subsection{Métriques}
Les deux indicateurs de mesure $\Upsilon$, pour la convergence et
$\Delta$, pour la diversité, sont issus de l'article de NSGA2 et sont
les mêmes que ceux utilisés lors du TP2.

\subsubsection{Convergence}
La convergence $\Upsilon$ correspond à la distance moyenne du front
de Pareto que l'algorithme a calculé par rapport au front de Pareto
optimal.\\


Plus $\Upsilon$ tend vers zéro, plus les solutions convergent vers
les solutions optimales.

\subsubsection{Diversité}
L'indicateur a été légèrement modifié. L'article précise qu'il faut
tracer une courbe parallèle au front de Pareto optimal. Les solutions
extrêmes obtenues sont alors utilisées pour calculer $d_f$ et
$d_l$. Par soucis de simplicité, $d_f$ et $d_l$ sont obtenues en
utilisant les solutions extrêmes du front de Pareto optimal lui
même. Cela biaise cependant légèrement cet indice en faveur d'un
algorithme qui converge mieux.\\

Plus $\Delta$ tend vers zéro, plus la diversité des solutions est
importante.

\begin{center}
  $\Delta = \frac{d_f + d_l + \sum_{i = 1}^{N - 1} |d_i - \bar{d}|}{d_f + d_l + (N - 1) \bar{d}}$
\end{center}

Avec $\bar{d}$, la distance consécutive moyenne des points.

\subsection{Résultats}

\newpage

\section{Conclusion}


\newpage

\section{Figures}

\FloatBarrier

\allBenchs{}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
